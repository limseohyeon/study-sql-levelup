# 1강. DBMS 아키텍처 개요

### 쿼리 평가 엔진

쿼리 평가 엔진은 사용자로부터 입력 받은 **SQL구문을 분석**하고, **어떤 순서로 기억 장치의 데이터에 접근할 지를 결정**한다. 이 때 결정되는 계획은 ⭐**실행 계획**⭐이라고 한다. 이러한 실행 계획에 기반을 둬서 데이터에 접근하는 방법을 **접근 메서드**라고 부른다.
<br><br>
> 🤔 **실행계획과 접근메서드**
> 

접근 메서드는 실행 계획의 일부이다. 접근 메서드는 ***테이블, 인덱스에 접근하는 방법***을 말한다. 접근 메서드의 종류는 다음과 같다.
| **접근 메서드** | **설명** |
| --- | --- |
| **Table Full Scan** | 테이블을 처음부터 끝까지 다 조회한다. |
| **Index Scan** | 인덱스를 통해 조건에 맞는 데이터만 접근한다. |
| **Index Range Scan** | 인덱스 범위를 정해 읽는다. (예시: age > 30) |
| **Index Unique Scan** | pk같은 유일한 인덱스를 사용해 한 개의 레코드만 조회한다. |


### 버퍼 매니저

DBMS는 **버퍼**라는 특별한 용도로 사용하는 메모리 영역을 확보한다. 이 메모리 영역을 관리하는 것이 버퍼 매니저이다.   

### 디스크 용량 매니저

디스크 용량 매니저는 어디에 어떻게 데이터를 저장할지 관리하며, 데이터의 읽고 쓰기를 제어한다. 

### 트랜잭션 매니저와 락 매니저

상용 시스템에서는 다수의 사람이 동시에 데이터베이스에 접근하게 된다. 이 때, 각각의 처리는 DBMS 내부에서 트랜잭션이라는 단위로 관리된다. 트랜잭션의 정합성을 유지하면서 실행시키고, 필요한 경우 데이터에 락을 걸어 다른 사람의 요청을 대기 시키는 것이 트랜잭션 매니저와 락매니저의 역할이다.

### 리커버리 매니저

시스템에 장애가 발생했을 때를 대비해서 데이터를 정기적으로 백업한다. 그리고, 실제 문제가 일어났을 때, 데이터를 복구해주는 기능을 한다.
<br><br><br><br><br>
# 2강. DBMS와 버퍼
## DBMS와 기억장치

DBMS는 데이터 저장을 목적으로 하는 미들웨어이며, 기억장치와 떨어뜨릴 수 없는 관계이다. DBMS가 사용하는 대표적인 기억장치는 ***하드디스크(HDD)와 메모리***다.

- **하드디스크(HDD)**

DBMS가 데이터를 저장하는 저장소는 대부분 하드디스크이다. 하드디스크는 2차 기억장치에 분류되어 접근 속도와 기억 비용이 평균적인 수치를 가진다.

- **메모리**

메모리는 1차 기억장치에 분류되며, 접근속도가 굉장히 빠르다. 그러나, 기억비용도 높기 때문에 모든 데이터를 메모리에 저장할 수는 없다. 따라서, DBMS는 **일부 데이터만** 메모리에 올려 성능을 향상시킨다. 
<br><br>
### 버퍼로 사용되는 메모리

자주 접근하는 데이터를 메모리에 올리면, 같은 SQL 구문을 실행해도 디스크가 아닌 메모리에 접근해서 빠르게 데이터를 검색할 수 있다. 디스크 접근의 감소는 성능 향상으로 이어진다. *일반적으로 SQL 구문의 실행 시간 대부분을 저장소 I/O 입출력에 사용하기 때문이다.*

이렇게 성능 향상을 목적으로 데이터를 저장하는 메모리를 **버퍼 또는 캐시**라고 부른다. DBMS의 버퍼 매니저가 *버퍼에 데이터를 어떻게, 어느정도의 기간 동안 올릴지*를 관리한다.
<br><br>
### 두 개의 버퍼

DBMS에는 ***데이터 캐시***와 ***로그 버퍼***의 역할을 하는 메모리 영역을 가지고 있다. 사용자는 용도에 따라 크기를 변경할 수 있다.

- **데이터 캐시 → 검색**
    
    데이터 캐시는 디스크에 있는 데이터의 일부를 메모리에 유지하기 위해 사용하는 메모리 영역이다. 
    
- **로그 버퍼 → 갱신**
    
    DBMS는 갱신과 관련된 SQL 구문을 사용자로부터 받고, 바로 저장소에 있는 데이터를 변경하지 않는다. 일단, *로그 버퍼에 변경 정보를 보내고 이후 디스크에 변경을 수행한다.* 데이터베이스의 갱신처리는 SQL 구문의 실행 시점과 저장소 갱신 시점에 차이가 있는 **비동기 처리**다. 
    
<br><br>
> 📎 **DBMS는 갱신 처리를 왜 비동기로 할까?**
> 

갱신할 때 , 시간 소모가 많이 되기 때문에 저장소 변경이 끝날 때 까지 기다려야 한다면, 사용자는 장시간 대기하게 된다. 따라서 메모리에 갱신 정보를 받은 시점에 사용자에게 해당 SQL 구문이 끝났다고 통지하고, 내부적으로 관련된 처리를 계속 수행하게 된다. → **성능 향상**을 위해서! 비동기 처리를 한다.
<br><br>
### 메모리 성질이 초래하는 트레이드 오프

메모리의 특징 중 하나는 **휘발성**이다. 따라서 DBMS를 껐다 켜면 메모리에 있던 모든 데이터가 사라진다. 

- **휘발성의 문제점**

데이터 캐시의 경우, 장애로 인해 메모리 위의 데이터가 사라져도, 디스크에서 원본 데이터를 읽어오면 되기 때문에 문제가 없다.

그러나, 로그버퍼의 경우는 다르다. DBMS는 로그 버퍼에 변경 정보를 저장해두고, 이후 디스크에 존재하는 원본데이터를 변경한다. 장애가 발생하면, 변경 사항이 완전히 사라져서 복구가 불가능해져서 데이터 부정합을 발생시킨다. 따라서 휘발성이라는 특징은 **로그 버퍼**에 치명적이다.

- **성능과 데이터 정합성**

로그 파일에 전달된 갱신 정보가 DBMS가 다운될 때 사라지는 현상은 DBMS가 갱신을 비동기로 하는 이상, 언제든 발생할 수 있는 문제이다. 따라서 이를 회피하고자 **DBMS는 커밋 시점에 반드시 갱신 정보를 로그파일에 씀**으로써, **장애가 발생해도 정합성을 유지**할 수 있도록 한다. 커밋 때는 반드시 디스크에 동기 접근이 일어나는데, 이 때 지연 발생 가능성이 있다. → **성능과 데이터 정합성 간**의 트레이드 오프가 발생한다.
<br><br>
### 시스템 특성에 따른 트레이드 오프

- **데이터 캐시와 로그 버퍼의 크기**

메모리는 기억비용이 높다. 따라서 자원이 한정되어 있기 때문에 메모리 크기를 어떻게 배분하는지도 성능에 영향을 미친다. 기본적으로 DBMS는 데이터 캐시에 더 많은 크기의 메모리 영역을 할당한다. 이는 데이터베이스가 기본적으로 검색을 메인으로 처리한다고 가정하기 때문이다. 그러나, 시스템의 특성에 따라서 갱신이 많다면, 로그 버퍼를 늘려 최적화를 진행할 수 있다.

✅데이터 캐시(검색), 로그버퍼(갱신)
<br><br>
### 워킹 메모리

- **워킹 메모리 개념**
    
    DBMS에서 버퍼 이외의 추가적인 메모리 영역이 있는데, 이를 워킹 메모리라고 부른다. 워킹 메모리는 **정렬, 해시** 관련 처리에서 사용되는 작업용 영역이다. 이 메모리는 작업이 종료되는 해제되는 임시 영역이다.
    
- **워킹 메모리가 부족하다면?**
    
    워킹 메모리가 부족하면 임시적인 영역을 사용하게 되는데, 임시적으로 사용하는 영역은 느린 속도의 **디스크**를 사용하기 때문에 성능에 영향을 미친다.
    
<br><br>
> **✅메모리 정리**

데이터 캐시 : 자주 사용되는 데이터는 데이터 캐시에 적재한다. 검색 시 성능 향상을 위해 사용된다.

로그 퍼버 : 변경 요청이 들어오면 로그 버퍼에 저장해둔 뒤, 디스크의 데이터를 변경한다. 갱신 시 성능 향상을 위해 사용한다.

워킹 메모리 : 정렬이나 해시 관련 처리에서 사용되는 작업용 메모리 영역이다.
<br><br><br><br><br>
# 3강. DBMS와 실행 계획

## 데이터에 접근하는 방법이 결정되는 과정

![image.png](attachment:7ef3b85b-c1ec-4475-9114-305dea36b3e7:image.png)

### 파서

파서는 구문 분석한다. 사용자가 입력한 SQL 구문이 올바른지 검사하고, SQL 구문을 정형적인 형식으로 변환한다.
<br><br>
### 옵티마이저

파서를 통해 변환된 쿼리는 옵티마이저로 이동한다. 옵티마이저는 인덱스 유무, 데이터 분산 또는 편향 정도, DBMS 내부 매개변수 등의 조건을 고려하여 비용을 연산하고, 가장 낮은 비용을 가진 실행 계획을 선택한다.
<br><br>
### 카탈로그 매니저

옵티마이저가 실행계획을 세울 때, 옵티마이저에게 중요한 정보를 제공하는 것이 카탈로그 매니저이다. 

> 📌 **카탈로그 :** DBMS의 내부 정보를 모아놓은 테이블들로, 테이블 또는 인덱스의 통계정보가 저장되어 있다.
> - 각 테이블의 레코드 수, 각 테이블의 필드 수와 필드의 크기, 필드의 카디널리티, 필드 값의 히스토그램, 필드 내부에 있는 NULL의 수, 인덱스 정보

<br><br>
### 플랜 평가

옵티마이저가 SQL 구문에서 여러 개의 실행 계획을 세운 뒤, 그것을 받아 최적의 실행 결과를 선택하는 것이 플랜 평가이다. 

🤔 사실 이 부분에서 공부를 하며 많이 헷갈렸다. 분명 옵티마이저가 실행 계획을 자동으로 선택할 텐데, 책에서는 플랜평가라는 단계를 별도로 분리해 설명하고 있기 때문이었다.

→ 내가 이해한 바는 다음과 같다. 

> 플랜 평가는 **옵티마이저 내부에서 자동으로 선택지 중 최적의 실행계획을 선택하는 과정**이기도 하고, 그 결과를 **DBA나 개발자가 검토 및 튜닝을 하는 과정**이기도 하다. 책에서 옵티마이저와 플랜 평가가 분리해 표현한 것은, **평가 주체의 차이**를 표현한 것 같다.

<br><br><br>
## 옵티마이저와 통계 정보

플랜 선택을 옵티마이저에게 맡기는 경우, 최적의 플랜이 선택되지 않는 경우가 많다. 이는 통계정보가 부족한 경우가 대표적인 원인으로 꼽힌다. **구식 정보를 바탕으로 플랜을 만들게 두지 말자!** 통계정보는 수동으로 갱신할 수도 있지만, 데이터를 크게 갱신하는 배치 처리가 있을 때는 Job Net을 조합하는 경우도 있다. 

통계 정보 갱신은 실행 비용이 굉장히 높은 작업이지만, DBMS가 최적의 플랜을 선택하도록 하기 위해서는 **꼭!** 필요한 조건이다. 따라서 갱신 시점을 확실하게 검토해야 한다.

- 통계 정보 갱신 명령어
    
    
    | **DBMS** | **명령어** |
    | --- | --- |
    | **Oracle** | exec DBMS_STATS.GATHER_TABLE_STATS(OWNNAME⇒[스키마 이름], TABNAME⇒[테이블 이름]); |
    | **Microsoft SQL Server** | UPDATE STATISTICS [테이블 이름] |
    | **DB2** | RUNSTATS ON TABLE [스키마 이름].[테이블 이름]; |
    | **PostgreSQL** | ANALYZE [스키마 이름].[테이블 이름]; |
    | **MySQL** | ANALYZE TABLE [스키마 이름].[테이블 이름]; |
<br><br><br><br><br>
# 4강. 실행 계획이 SQL 구문의 성능을 결정

쿼리 평가 엔진으로부터 도출된 실행 계획을 바탕으로 데이터 접근을 수행한다.

1장 4강에서는 아래의 기본적인 SQL 구문의 실행 계획을 살펴보고자 한다.

> ① 테이블 풀 스캔의 실행 계획 (하나의 테이블에 있는 데이터를 전체 조회)<br>
> ② 인덱스 스캔의 실행 계획 (하나의 테이블에서 where 절을 사용해 선택 조회)<br>
> ③ 간단한 테이블 결합의 실행 계획 (두 개의 테이블을 join으로 결합하여 조회)<br>

해당 도서(SQL 레벨업)에서는 Oracle과 PostgreSQL을 사용해 예시를 든다.

각각의 DBMS에서 실행계획을 출력하는 경우, 공통적으로 출력되는 세 가지 요소를 볼 수 있다.

1. **`조작 대상 객체` :**  조작하고자 하는 객체가 무엇인지 출력된다. 테이블, 인덱스, 파티션, 시퀀스처럼 SQL 구문으로 조작할 수 있는 객체가 출력된다.
2. **`객체에 대한 조작의 종류`**
3. **`조작 대상이 되는 레코드 수`**

위 세 가지 요소를 토대로 실행 계획을 본다.
<br><br>
## ① 테이블 풀 스캔의 실행 계획

```sql
SELECT * FROM Shops;
```

- 조작 대상 객체 : Shops 객체에 대해 조작하고 있기 때문에 **shops**가 출력된다.
- **객체에 대한 조작의 종류**
    - Oracle : Operation 필드로 출력된다.
        - **`TABLE ACCESS FULL` :** 테이블의 전체 데이터를 조회
    - PostgreSQL : 문장의 앞 부분에 출력된다.
        - **`Seq Scan` :** 파일을 순차적으로 접근해서 해당 테이블의 전체 데이터를 조회
- 조작 대상이 되는 레코드 수 :  Rows 항목에 출력된다. 결합이 있으면 하나의 SQL구문을 실행해도 여러 개의 조작이 수행된다. 각각의 조작에서 얼마만큼의 레코드가 처리되는지는 SQL 구문 전체의 실행 비용을 파악하는데 중요한 지표가 된다. 해당 도서에서는 Shops 테이블에 60개의 데이터를 넣었기 때문에 60이 출력된다.
    - 옵티마이저에서 비용 계산할 때, 고려하는 카탈로그의 레코드 수와 차이가 있을 수 있다.
<br><br><br>
## ② 인덱스 스캔의 실행 계획

```sql
SELECT * FROM Shops WHERE shop_id = '00050';
```

- 조작 대상 객체: pk_shops가 추가되었다.
- 객체에 대한 조작의 종류
    - Oracle
        - **`INDEX UNIQUE SCAN`**
        - **`TABLE ACCESS BY INDEX ROWID`**
    - PostgreSQL
        - **`Index_Scan`**
- 조작 대상이 되는 레코드 수 : 모든 데이터를 조회했던 ①과는 달리 ②에서는 where 절을 통해 기본 키가 00050인 레코드를 지정했으므로 1이 출력된다.

- 인덱스와 속도
    
    풀 스캔의 경우, 모집합의 데이터 양에 비례해서 처리 비용 증가
    
    인덱스 사용의 경우, B-tree가 모집합의 데이터 양에 따라 대수 함수적으로 처리비용 증가(완만하게 증가)
    
    따라서, 특정 데이터 양을 손익 분기점으로 **인덱스 스캔이 효율적**으로 접근할 수 있게 된다.
<br><br><br>
## ③ 간단한 테이블 결합의 실행 계획

**`join`** 을 사용하기 위해 reservation 테이블을 추가한다. 해당 테이블에는 10개의 데이터가 존재한다.

```sql
SELECT shop_name 
FROM Shops S 
INNER JOIN Reservations R 
ON S.shop_id = R.shop_id;
```

DBMS가 결합할 때, 세 가지 종류의 알고리즘을 사용한다.

- **`Nested Loops`** : 한쪽 테이블을 읽으면서 레코드 하나마다 결합 조건에 맞는 레코드를 다른 쪽 테이블에서 찾는 방식
- **`Sort Merge`** : 결합 키를 기준으로 두 개의 테이블을 정렬하고, 결합하는 방식 (워킹 메모리 영역 사용)
- **`Hash`** : 결합 키값을 해시 값으로 매핑하는 방식 (워킹 메모리 영역 사용)

- 객체에 대한 조작의 종류 : PostgreSQL과 Oracle의 예시를 보면 두 개의 DBMS 모두 **Nested Loop**를 사용하고 있다.

실행 계획은 일반적으로 **트리 구조**를 가지며, 중첩 단계가 **깊을 수록 먼저** 실행된다. 중첩 단계가 동일한 경우에는 **위에서 아래**로 실행한다.
