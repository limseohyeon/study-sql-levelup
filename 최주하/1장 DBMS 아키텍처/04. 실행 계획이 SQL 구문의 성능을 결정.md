# 4강. 실행 계획이 SQL 구문의 성능을 결정

쿼리 평가 엔진으로부터 도출된 실행 계획을 바탕으로 데이터 접근을 수행한다.

1장 4강에서는 아래의 기본적인 SQL 구문의 실행 계획을 살펴보고자 한다.

> ① 테이블 풀 스캔의 실행 계획 (하나의 테이블에 있는 데이터를 전체 조회)<br>
> ② 인덱스 스캔의 실행 계획 (하나의 테이블에서 where 절을 사용해 선택 조회)<br>
> ③ 간단한 테이블 결합의 실행 계획 (두 개의 테이블을 join으로 결합하여 조회)<br>

해당 도서(SQL 레벨업)에서는 Oracle과 PostgreSQL을 사용해 예시를 든다.

각각의 DBMS에서 실행계획을 출력하는 경우, 공통적으로 출력되는 세 가지 요소를 볼 수 있다.

1. **`조작 대상 객체` :**  조작하고자 하는 객체가 무엇인지 출력된다. 테이블, 인덱스, 파티션, 시퀀스처럼 SQL 구문으로 조작할 수 있는 객체가 출력된다.
2. **`객체에 대한 조작의 종류`**
3. **`조작 대상이 되는 레코드 수`**

위 세 가지 요소를 토대로 실행 계획을 본다.
<br><br>
## ① 테이블 풀 스캔의 실행 계획

```sql
SELECT * FROM Shops;
```

- 조작 대상 객체 : Shops 객체에 대해 조작하고 있기 때문에 **shops**가 출력된다.
- **객체에 대한 조작의 종류**
    - Oracle : Operation 필드로 출력된다.
        - **`TABLE ACCESS FULL` :** 테이블의 전체 데이터를 조회
    - PostgreSQL : 문장의 앞 부분에 출력된다.
        - **`Seq Scan` :** 파일을 순차적으로 접근해서 해당 테이블의 전체 데이터를 조회
- 조작 대상이 되는 레코드 수 :  Rows 항목에 출력된다. 결합이 있으면 하나의 SQL구문을 실행해도 여러 개의 조작이 수행된다. 각각의 조작에서 얼마만큼의 레코드가 처리되는지는 SQL 구문 전체의 실행 비용을 파악하는데 중요한 지표가 된다. 해당 도서에서는 Shops 테이블에 60개의 데이터를 넣었기 때문에 60이 출력된다.
    - 옵티마이저에서 비용 계산할 때, 고려하는 카탈로그의 레코드 수와 차이가 있을 수 있다.
      <br><br><br>
## ② 인덱스 스캔의 실행 계획

```sql
SELECT * FROM Shops WHERE shop_id = '00050';
```

- 조작 대상 객체: pk_shops가 추가되었다.
- 객체에 대한 조작의 종류
    - Oracle
        - **`INDEX UNIQUE SCAN`**
        - **`TABLE ACCESS BY INDEX ROWID`**
    - PostgreSQL
        - **`Index_Scan`**
- 조작 대상이 되는 레코드 수 : 모든 데이터를 조회했던 ①과는 달리 ②에서는 where 절을 통해 기본 키가 00050인 레코드를 지정했으므로 1이 출력된다.

- 인덱스와 속도

  풀 스캔의 경우, 모집합의 데이터 양에 비례해서 처리 비용 증가

  인덱스 사용의 경우, B-tree가 모집합의 데이터 양에 따라 대수 함수적으로 처리비용 증가(완만하게 증가)

  따라서, 특정 데이터 양을 손익 분기점으로 **인덱스 스캔이 효율적**으로 접근할 수 있게 된다.
  <br><br><br>
## ③ 간단한 테이블 결합의 실행 계획

**`join`** 을 사용하기 위해 reservation 테이블을 추가한다. 해당 테이블에는 10개의 데이터가 존재한다.

```sql
SELECT shop_name 
FROM Shops S 
INNER JOIN Reservations R 
ON S.shop_id = R.shop_id;
```

DBMS가 결합할 때, 세 가지 종류의 알고리즘을 사용한다.

- **`Nested Loops`** : 한쪽 테이블을 읽으면서 레코드 하나마다 결합 조건에 맞는 레코드를 다른 쪽 테이블에서 찾는 방식
- **`Sort Merge`** : 결합 키를 기준으로 두 개의 테이블을 정렬하고, 결합하는 방식 (워킹 메모리 영역 사용)
- **`Hash`** : 결합 키값을 해시 값으로 매핑하는 방식 (워킹 메모리 영역 사용)

- 객체에 대한 조작의 종류 : PostgreSQL과 Oracle의 예시를 보면 두 개의 DBMS 모두 **Nested Loop**를 사용하고 있다.

실행 계획은 일반적으로 **트리 구조**를 가지며, 중첩 단계가 **깊을 수록 먼저** 실행된다. 중첩 단계가 동일한 경우에는 **위에서 아래**로 실행한다.
